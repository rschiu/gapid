{{/*
 * Copyright (C) 2019 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */}}

{{Global "Vulkan.LayerName" "VkApi"}}
{{Global "Vulkan.LayerNamespace" "vk_api"}}
{{Global "Vulkan.Layer Description" "Vulkan API Layer"}}

{{Global "Vulkan.OverrideFunctions" "vkQueueSubmit" "vkDebugMarkerSetObjectNameEXT" "vkDebugMarkerSetObjectTagEXT" "vkSetDebugUtilsObjectNameEXT" "vkCmdDebugMarkerBeginEXT" "vkCmdDebugMarkerEndEXT" "vkCmdDebugMarkerInsertEXT"}}

{{Include "../../../../gapis/api/vulkan/templates/vulkan_layer.tmpl"}}

{{$ | Macro "layer_impl.cpp" | Reflow 4 | Write "layer_impl.cpp"}}

{{define "layer_impl.cpp"}}
{{Template "C++.Copyright"}}
//#include "core/vulkan/vk_api/cc/layer.h"
//#include "core/vulkan/vk_api/cc/tracing_helpers.h"

#include <cinttypes>
#include <cstdio>
#include <cstring>
#include <mutex>
#include <sstream>
#include <type_traits>
#include <unordered_map>
#include <vector>

#include <vulkan/vk_layer.h>
#include <vulkan/vulkan.h>

#include <android/log.h>
#include "protos/perfetto/trace/gpu/gpu_render_stage_event.pbzero.h"
//#include "protos/perfetto/trace/gpu/vulkan_api_event.pbzero.h"
#include "layer.h"

#include <android/trace.h>
//#include "core/vulkan/vk_api/cc/tracing_helpers.h"
#define LAYER_NAME "VkApi"

#define LAYER_NAME_FUNCTION(fn) VkApi##fn

#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LAYER_NAME, __VA_ARGS__);

#define ATRACE_NAME(name) ScopedTrace ___tracer(name)

// ATRACE_CALL is an ATRACE_NAME that uses the current function name.
#define ATRACE_CALL() ATRACE_NAME(__FUNCTION__)

class ScopedTrace {
  public:
    inline ScopedTrace(const char *name) {
      ATrace_beginSection(name);
    }

    inline ~ScopedTrace() {
      ATrace_endSection();
    }
};

namespace vk_api {

VkResult vkQueueSubmit(
    PFN_vkQueueSubmit next,
    VkQueue                                     queue,
    uint32_t                                    submitCount,
    const VkSubmitInfo*                         pSubmits,
    VkFence                                     fence) {
  ATRACE_CALL();
  if (ATrace_isEnabled()) {
    {
      std::stringstream ss;
      ss << "VkQueue: " << reinterpret_cast<std::uintptr_t>(queue);
      ATRACE_NAME(ss.str().c_str());
    }
    for (uint32_t i = 0; i < submitCount; i++) {
      for (uint32_t j = 0; j < pSubmits[i].commandBufferCount; j++) {
        std::stringstream ss;
        ss << "VkCommandBuffer: "
          << reinterpret_cast<std::uintptr_t>(
              pSubmits[i].pCommandBuffers[j]);
        ATRACE_NAME(ss.str().c_str());
      }
    }
  }
  LOGI("vkQueueSubmit");
  return next(queue, submitCount, pSubmits, fence);
}



VkResult vkDebugMarkerSetObjectNameEXT(
    PFN_vkDebugMarkerSetObjectNameEXT next,
    VkDevice device,
    VkDebugMarkerObjectNameInfoEXT const* pNameInfo) {

  static int cnt = 1;
  LOGI("vkDebugMarkerSetObjectNameEXT");
  //VkApiDataSource::Trace([&](VkApiDataSource::TraceContext ctx) {
  //    LOGI("VkApiDataSource tracing lambda called");
  //    auto data_source = ctx.GetDataSourceLocked();
  //    {
  //      auto packet = ctx.NewTracePacket();
  //      packet->set_timestamp(cnt * 10 - 1);
  //      auto event = packet->set_vk_debug_marker();
  //      event->set_vk_device(reinterpret_cast<uint64_t>(device));
  //      event->set_object_type(::perfetto::protos::pbzero::VkDebugMarkerObjectName_VkObjectType(pNameInfo->objectType));
  //      event->set_object(pNameInfo->object);
  //      event->set_object_name(pNameInfo->pObjectName);
  //    }
  //});
  //GpuRenderStageDataSource::Trace([&](GpuRenderStageDataSource::TraceContext ctx) {
  //    LOGI("GpuRenderStageDataSource tracing lambda called");
  //    auto data_source = ctx.GetDataSourceLocked();
  //    if (data_source->first) {
  //      data_source->count = 0;
  //      auto packet = ctx.NewTracePacket();
  //      packet->set_timestamp(0);
  //      auto event = packet->set_gpu_render_stage_event();
  //      auto spec = event->set_specifications();
  //      auto hw_queue = spec->add_hw_queue();
  //      hw_queue->set_name("queue 0");
  //      hw_queue = spec->add_hw_queue();
  //      hw_queue->set_name("queue 1");
  //      auto stage = spec->add_stage();
  //      stage->set_name("stage 0");
  //      stage = spec->add_stage();
  //      stage->set_name("stage 1");
  //      stage = spec->add_stage();
  //      stage->set_name("stage 2");
  //      packet->Finalize();
  //      data_source->first = false;
  //    }
  //    {
  //      auto packet = ctx.NewTracePacket();
  //      packet->set_timestamp(cnt * 10);
  //      auto event = packet->set_gpu_render_stage_event();
  //      event->set_event_id(cnt);
  //      event->set_duration(5);
  //      event->set_hw_queue_id(cnt % 2);
  //      event->set_stage_id(cnt % 3);
  //      event->set_context(42);
  //      event->set_render_target_handle(pNameInfo->object);
  //      cnt++;
  //    }
  //});

  return VK_SUCCESS;
}

VkResult vkDebugMarkerSetObjectTagEXT(
    PFN_vkDebugMarkerSetObjectTagEXT next,
    VkDevice device,
    VkDebugMarkerObjectTagInfoEXT const* pTagInfo) {

  LOGI("vkDebugMarkerSetObjectTagEXT");

  if (next != nullptr) {
    return next(device, pTagInfo);
  } else {
    return VK_SUCCESS;
  }
}

VkResult vkSetDebugUtilsObjectNameEXT(
    PFN_vkSetDebugUtilsObjectNameEXT next,
    VkDevice                                    device,
    const VkDebugUtilsObjectNameInfoEXT*        pNameInfo) {
  LOGI("vkSetDebugUtilsObjectNameEXT");

  return next(device, pNameInfo);
}

void vkCmdDebugMarkerBeginEXT(
    PFN_vkCmdDebugMarkerBeginEXT next,
    VkCommandBuffer                             commandBuffer,
    VkDebugMarkerMarkerInfoEXT const*                 pMarkerInfo) {
}

void vkCmdDebugMarkerEndEXT(
    PFN_vkCmdDebugMarkerEndEXT next,
    VkCommandBuffer                             commandBuffer) {
}


void vkCmdDebugMarkerInsertEXT(
    PFN_vkCmdDebugMarkerInsertEXT next,
    VkCommandBuffer commandBuffer,
    VkDebugMarkerMarkerInfoEXT const* pMarkerInfo) {
}

}  // namespace vk_api


{{end}}
